package vulnerability

import (
	"context"
	"encoding/json"
	"fmt"
	"os/exec"

	"github.com/klamhq/facter-oss/pkg/models"
	schema "github.com/klamhq/facter-schema/proto/klamhq/rpc/facter/v1"
	"github.com/sirupsen/logrus"
)

// RunTrivyScan executes a Trivy scan on the root filesystem and returns a slice of matched vulnerabilities.
// It uses the Trivy CLI tool to scan for vulnerabilities in installed packages and matches them against the provided package list.
func RunTrivyScan(ctx context.Context, logger *logrus.Logger, packages []*schema.Package) []models.PackageVulnMatch {
	cmd := exec.CommandContext(ctx, "trivy", "rootfs", "--scanners", "vuln", "--skip-dirs", "/run", "--pkg-types", "os", "--format", "json", "--quiet", "/")
	out, err := cmd.Output()
	if err != nil {
		logger.Errorf("Unable to run trivy %s:", err)
	}

	var output models.TrivyOutput
	err = json.Unmarshal(out, &output)
	if err != nil {
		logger.Errorf("Unable to unmarshall trivy json %s:", err)
	}
	packageVulnMatch := MatchVulns(logger, packages, &output)
	return packageVulnMatch
}

// MatchVulns matches vulnerabilities from Trivy output with installed packages.
// It creates a map of package names to versions and checks if the installed version matches the version reported by Trivy.
func MatchVulns(logger *logrus.Logger, packages []*schema.Package, trivyOutput *models.TrivyOutput) []models.PackageVulnMatch {
	pkgMap := make(map[string]string)
	for _, pkg := range packages {
		pkgMap[pkg.Name] = pkg.Version
	}

	matches := make(map[string]*models.PackageVulnMatch)

	for _, res := range trivyOutput.Results {
		for _, vuln := range res.Vulnerabilities {
			installedVersion, found := pkgMap[vuln.PkgName]
			matchKey := fmt.Sprintf("%s@%s", vuln.PkgName, vuln.InstalledVersion)

			if _, exists := matches[matchKey]; !exists {
				matches[matchKey] = &models.PackageVulnMatch{
					PackageName:      vuln.PkgName,
					InstalledVersion: vuln.InstalledVersion,
					Vulnerabilities:  []models.MatchedVuln{},
					Matched:          found && installedVersion == vuln.InstalledVersion,
				}
			}

			matches[matchKey].Vulnerabilities = append(matches[matchKey].Vulnerabilities, models.MatchedVuln{
				VulnerabilityId: vuln.VulnerabilityID,
				Severity:        vuln.Severity,
				Title:           vuln.Title,
				Description:     vuln.Description,
				FixedVersion:    vuln.FixedVersion,
			})

			if found && installedVersion == vuln.InstalledVersion {
				logger.Debugf("Matched vulnerability: %s, Package: %s, Version: %s", vuln.VulnerabilityID, vuln.PkgName, vuln.InstalledVersion)
			} else {
				logger.Debugf("Unmatched vulnerability: %s, Package: %s, Version: %s", vuln.VulnerabilityID, vuln.PkgName, vuln.InstalledVersion)
			}
		}
	}

	var vulnsMatch []models.PackageVulnMatch
	for _, match := range matches {
		vulnsMatch = append(vulnsMatch, *match)
	}

	return vulnsMatch
}
