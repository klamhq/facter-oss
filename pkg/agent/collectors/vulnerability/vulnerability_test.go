package vulnerability

import (
	"testing"

	"github.com/klamhq/facter-oss/pkg/models"
	schema "github.com/klamhq/facter-schema/proto/klamhq/rpc/facter/v1"
	"github.com/sirupsen/logrus"
)

func TestMatchVulns_MatchedVulnerability(t *testing.T) {
	logger := logrus.New()
	pkgs := []*models.Package{
		{Name: "openssl", Version: "1.1.1"},
	}
	trivyOutput := &models.TrivyOutput{
		Results: []models.Result{
			{
				Vulnerabilities: []models.Vulnerability{
					{
						PkgName:          "openssl",
						InstalledVersion: "1.1.1",
						VulnerabilityID:  "CVE-1234-5678",
						Severity:         "HIGH",
						Title:            "Test Vulnerability",
						Description:      "A test vulnerability",
						FixedVersion:     "1.1.2",
					},
				},
			},
		},
	}
	p := []*schema.Package{
		{
			Name:    pkgs[0].Name,
			Version: pkgs[0].Version,
		},
	}
	result := MatchVulns(logger, p, trivyOutput)
	if len(result) != 1 {
		t.Fatalf("expected 1 match, got %d", len(result))
	}
	match := result[0]
	if !match.Matched {
		t.Errorf("expected match to be true")
	}
	if match.PackageName != "openssl" {
		t.Errorf("expected PackageName 'openssl', got '%s'", match.PackageName)
	}
	if match.InstalledVersion != "1.1.1" {
		t.Errorf("expected InstalledVersion '1.1.1', got '%s'", match.InstalledVersion)
	}
	if len(match.Vulnerabilities) != 1 {
		t.Errorf("expected 1 vulnerability, got %d", len(match.Vulnerabilities))
	}
	if match.Vulnerabilities[0].VulnerabilityId != "CVE-1234-5678" {
		t.Errorf("unexpected VulnerabilityId: %s", match.Vulnerabilities[0].VulnerabilityId)
	}
}

func TestMatchVulns_UnmatchedVulnerability(t *testing.T) {
	logger := logrus.New()
	pkgs := []*models.Package{
		{Name: "openssl", Version: "1.1.1"},
	}
	trivyOutput := &models.TrivyOutput{
		Results: []models.Result{
			{
				Vulnerabilities: []models.Vulnerability{
					{
						PkgName:          "openssl",
						InstalledVersion: "1.0.2",
						VulnerabilityID:  "CVE-9999-0000",
						Severity:         "LOW",
						Title:            "Old Vulnerability",
						Description:      "An old vulnerability",
						FixedVersion:     "1.0.3",
					},
				},
			},
		},
	}

	p := []*schema.Package{
		{
			Name:    pkgs[0].Name,
			Version: pkgs[0].Version,
		},
	}
	result := MatchVulns(logger, p, trivyOutput)
	if len(result) != 1 {
		t.Fatalf("expected 1 match, got %d", len(result))
	}
	match := result[0]
	if match.Matched {
		t.Errorf("expected match to be false")
	}
	if match.PackageName != "openssl" {
		t.Errorf("expected PackageName 'openssl', got '%s'", match.PackageName)
	}
	if match.InstalledVersion != "1.0.2" {
		t.Errorf("expected InstalledVersion '1.0.2', got '%s'", match.InstalledVersion)
	}
}

func TestMatchVulns_MultipleVulnerabilitiesAndPackages(t *testing.T) {
	logger := logrus.New()
	pkgs := []*models.Package{
		{Name: "openssl", Version: "1.1.1"},
		{Name: "curl", Version: "7.68.0"},
	}
	trivyOutput := &models.TrivyOutput{
		Results: []models.Result{
			{
				Vulnerabilities: []models.Vulnerability{
					{
						PkgName:          "openssl",
						InstalledVersion: "1.1.1",
						VulnerabilityID:  "CVE-1111-1111",
						Severity:         "MEDIUM",
						Title:            "OpenSSL Vuln",
						Description:      "OpenSSL desc",
						FixedVersion:     "1.1.2",
					},
					{
						PkgName:          "curl",
						InstalledVersion: "7.68.0",
						VulnerabilityID:  "CVE-2222-2222",
						Severity:         "HIGH",
						Title:            "Curl Vuln",
						Description:      "Curl desc",
						FixedVersion:     "7.70.0",
					},
					{
						PkgName:          "curl",
						InstalledVersion: "7.68.0",
						VulnerabilityID:  "CVE-3333-3333",
						Severity:         "LOW",
						Title:            "Curl Vuln 2",
						Description:      "Curl desc 2",
						FixedVersion:     "7.69.0",
					},
				},
			},
		},
	}

	p := []*schema.Package{
		{
			Name:    pkgs[0].Name,
			Version: pkgs[0].Version,
		},
		{
			Name:    pkgs[1].Name,
			Version: pkgs[1].Version,
		},
	}
	result := MatchVulns(logger, p, trivyOutput)
	if len(result) != 2 {
		t.Fatalf("expected 2 matches, got %d", len(result))
	}
	var foundOpenSSL, foundCurl bool
	for _, match := range result {
		switch match.PackageName {
		case "openssl":
			foundOpenSSL = true
			if !match.Matched {
				t.Errorf("expected openssl match to be true")
			}
			if len(match.Vulnerabilities) != 1 {
				t.Errorf("expected 1 vulnerability for openssl, got %d", len(match.Vulnerabilities))
			}
		case "curl":
			foundCurl = true
			if !match.Matched {
				t.Errorf("expected curl match to be true")
			}
			if len(match.Vulnerabilities) != 2 {
				t.Errorf("expected 2 vulnerabilities for curl, got %d", len(match.Vulnerabilities))
			}
		default:
			t.Errorf("unexpected package: %s", match.PackageName)
		}
	}
	if !foundOpenSSL || !foundCurl {
		t.Errorf("did not find all expected packages")
	}
}

func TestMatchVulns_EmptyInputs(t *testing.T) {
	logger := logrus.New()
	trivyOutput := &models.TrivyOutput{}
	p := []*schema.Package{}
	result := MatchVulns(logger, p, trivyOutput)
	if len(result) != 0 {
		t.Errorf("expected 0 matches, got %d", len(result))
	}
}
