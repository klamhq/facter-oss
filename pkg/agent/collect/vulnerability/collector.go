package vulnerability

import (
	"context"
	"fmt"

	"github.com/klamhq/facter-oss/pkg/agent/collectors/vulnerability"
	"github.com/klamhq/facter-oss/pkg/options"
	"github.com/klamhq/facter-oss/pkg/utils"
	schema "github.com/klamhq/facter-schema/proto/klamhq/rpc/facter/v1"
	"github.com/sirupsen/logrus"
)

type VulnerabilityCollectorImpl struct {
	log *logrus.Logger
	cfg *options.VulnerabilitiesOptions
}

func New(log *logrus.Logger, cfg *options.VulnerabilitiesOptions) *VulnerabilityCollectorImpl {

	return &VulnerabilityCollectorImpl{
		log: log,
		cfg: cfg,
	}
}

func (c *VulnerabilityCollectorImpl) CollectVulnerability(ctx context.Context, packages []*schema.Package) (*schema.VulnerabilityReport, error) {
	if !utils.CheckBinInstalled(c.log, "trivy") {
		c.log.Error("Trivy is not installed, see here: https://trivy.dev/latest/getting-started/installation/ for installation instructions")
		return nil, fmt.Errorf("trivy is not installed, vulnerabilities report will not generated")
	}
	c.log.Info("Crafting packages vulnerabilities")
	vulnerabilityReport := &schema.VulnerabilityReport{}
	packageVulnMatch := vulnerability.RunTrivyScan(ctx, c.log, packages)
	vulnerabilityReport.Matches = make([]*schema.PackageVulnMatch, 0, len(packageVulnMatch))
	for _, match := range packageVulnMatch {
		pkgVulnMatch := &schema.PackageVulnMatch{
			PackageName:      match.PackageName,
			InstalledVersion: match.InstalledVersion,
			Matched:          match.Matched,
		}
		pkgVulnMatch.Vulnerabilities = make([]*schema.MatchedVuln, 0, len(match.Vulnerabilities))
		for _, vuln := range match.Vulnerabilities {
			pkgVulnMatch.Vulnerabilities = append(pkgVulnMatch.Vulnerabilities, &schema.MatchedVuln{
				VulnerabilityId: vuln.VulnerabilityId,
				Severity:        vuln.Severity,
				Title:           vuln.Title,
				Description:     vuln.Description,
				FixedVersion:    vuln.FixedVersion,
			})
		}
		vulnerabilityReport.Matches = append(vulnerabilityReport.Matches, pkgVulnMatch)
	}
	return vulnerabilityReport, nil
}
